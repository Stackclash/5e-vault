/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/papaparse/papaparse.min.js
var require_papaparse_min = __commonJS({
  "node_modules/papaparse/papaparse.min.js"(exports, module2) {
    !function(e, t) {
      "function" == typeof define && define.amd ? define([], t) : "object" == typeof module2 && "undefined" != typeof exports ? module2.exports = t() : e.Papa = t();
    }(exports, function s() {
      "use strict";
      var f = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== f ? f : {};
      var n = !f.document && !!f.postMessage, o = f.IS_PAPA_WORKER || false, a = {}, u = 0, b = { parse: function(e, t) {
        var r2 = (t = t || {}).dynamicTyping || false;
        J(r2) && (t.dynamicTypingFunction = r2, r2 = {});
        if (t.dynamicTyping = r2, t.transform = !!J(t.transform) && t.transform, t.worker && b.WORKERS_SUPPORTED) {
          var i = function() {
            if (!b.WORKERS_SUPPORTED) return false;
            var e2 = (r3 = f.URL || f.webkitURL || null, i2 = s.toString(), b.BLOB_URL || (b.BLOB_URL = r3.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", i2, ")();"], { type: "text/javascript" })))), t2 = new f.Worker(e2);
            var r3, i2;
            return t2.onmessage = _, t2.id = u++, a[t2.id] = t2;
          }();
          return i.userStep = t.step, i.userChunk = t.chunk, i.userComplete = t.complete, i.userError = t.error, t.step = J(t.step), t.chunk = J(t.chunk), t.complete = J(t.complete), t.error = J(t.error), delete t.worker, void i.postMessage({ input: e, config: t, workerId: i.id });
        }
        var n2 = null;
        b.NODE_STREAM_INPUT, "string" == typeof e ? (e = function(e2) {
          if (65279 === e2.charCodeAt(0)) return e2.slice(1);
          return e2;
        }(e), n2 = t.download ? new l(t) : new p(t)) : true === e.readable && J(e.read) && J(e.on) ? n2 = new g(t) : (f.File && e instanceof File || e instanceof Object) && (n2 = new c(t));
        return n2.stream(e);
      }, unparse: function(e, t) {
        var n2 = false, _2 = true, m2 = ",", y2 = "\r\n", s2 = '"', a2 = s2 + s2, r2 = false, i = null, o2 = false;
        !function() {
          if ("object" != typeof t) return;
          "string" != typeof t.delimiter || b.BAD_DELIMITERS.filter(function(e2) {
            return -1 !== t.delimiter.indexOf(e2);
          }).length || (m2 = t.delimiter);
          ("boolean" == typeof t.quotes || "function" == typeof t.quotes || Array.isArray(t.quotes)) && (n2 = t.quotes);
          "boolean" != typeof t.skipEmptyLines && "string" != typeof t.skipEmptyLines || (r2 = t.skipEmptyLines);
          "string" == typeof t.newline && (y2 = t.newline);
          "string" == typeof t.quoteChar && (s2 = t.quoteChar);
          "boolean" == typeof t.header && (_2 = t.header);
          if (Array.isArray(t.columns)) {
            if (0 === t.columns.length) throw new Error("Option columns is empty");
            i = t.columns;
          }
          void 0 !== t.escapeChar && (a2 = t.escapeChar + s2);
          ("boolean" == typeof t.escapeFormulae || t.escapeFormulae instanceof RegExp) && (o2 = t.escapeFormulae instanceof RegExp ? t.escapeFormulae : /^[=+\-@\t\r].*$/);
        }();
        var u2 = new RegExp(Q(s2), "g");
        "string" == typeof e && (e = JSON.parse(e));
        if (Array.isArray(e)) {
          if (!e.length || Array.isArray(e[0])) return h2(null, e, r2);
          if ("object" == typeof e[0]) return h2(i || Object.keys(e[0]), e, r2);
        } else if ("object" == typeof e) return "string" == typeof e.data && (e.data = JSON.parse(e.data)), Array.isArray(e.data) && (e.fields || (e.fields = e.meta && e.meta.fields || i), e.fields || (e.fields = Array.isArray(e.data[0]) ? e.fields : "object" == typeof e.data[0] ? Object.keys(e.data[0]) : []), Array.isArray(e.data[0]) || "object" == typeof e.data[0] || (e.data = [e.data])), h2(e.fields || [], e.data || [], r2);
        throw new Error("Unable to serialize unrecognized input");
        function h2(e2, t2, r3) {
          var i2 = "";
          "string" == typeof e2 && (e2 = JSON.parse(e2)), "string" == typeof t2 && (t2 = JSON.parse(t2));
          var n3 = Array.isArray(e2) && 0 < e2.length, s3 = !Array.isArray(t2[0]);
          if (n3 && _2) {
            for (var a3 = 0; a3 < e2.length; a3++) 0 < a3 && (i2 += m2), i2 += v2(e2[a3], a3);
            0 < t2.length && (i2 += y2);
          }
          for (var o3 = 0; o3 < t2.length; o3++) {
            var u3 = n3 ? e2.length : t2[o3].length, h3 = false, f2 = n3 ? 0 === Object.keys(t2[o3]).length : 0 === t2[o3].length;
            if (r3 && !n3 && (h3 = "greedy" === r3 ? "" === t2[o3].join("").trim() : 1 === t2[o3].length && 0 === t2[o3][0].length), "greedy" === r3 && n3) {
              for (var d2 = [], l2 = 0; l2 < u3; l2++) {
                var c2 = s3 ? e2[l2] : l2;
                d2.push(t2[o3][c2]);
              }
              h3 = "" === d2.join("").trim();
            }
            if (!h3) {
              for (var p2 = 0; p2 < u3; p2++) {
                0 < p2 && !f2 && (i2 += m2);
                var g2 = n3 && s3 ? e2[p2] : p2;
                i2 += v2(t2[o3][g2], p2);
              }
              o3 < t2.length - 1 && (!r3 || 0 < u3 && !f2) && (i2 += y2);
            }
          }
          return i2;
        }
        function v2(e2, t2) {
          if (null == e2) return "";
          if (e2.constructor === Date) return JSON.stringify(e2).slice(1, 25);
          var r3 = false;
          o2 && "string" == typeof e2 && o2.test(e2) && (e2 = "'" + e2, r3 = true);
          var i2 = e2.toString().replace(u2, a2);
          return (r3 = r3 || true === n2 || "function" == typeof n2 && n2(e2, t2) || Array.isArray(n2) && n2[t2] || function(e3, t3) {
            for (var r4 = 0; r4 < t3.length; r4++) if (-1 < e3.indexOf(t3[r4])) return true;
            return false;
          }(i2, b.BAD_DELIMITERS) || -1 < i2.indexOf(m2) || " " === i2.charAt(0) || " " === i2.charAt(i2.length - 1)) ? s2 + i2 + s2 : i2;
        }
      } };
      if (b.RECORD_SEP = String.fromCharCode(30), b.UNIT_SEP = String.fromCharCode(31), b.BYTE_ORDER_MARK = "\uFEFF", b.BAD_DELIMITERS = ["\r", "\n", '"', b.BYTE_ORDER_MARK], b.WORKERS_SUPPORTED = !n && !!f.Worker, b.NODE_STREAM_INPUT = 1, b.LocalChunkSize = 10485760, b.RemoteChunkSize = 5242880, b.DefaultDelimiter = ",", b.Parser = E, b.ParserHandle = r, b.NetworkStreamer = l, b.FileStreamer = c, b.StringStreamer = p, b.ReadableStreamStreamer = g, f.jQuery) {
        var d = f.jQuery;
        d.fn.parse = function(o2) {
          var r2 = o2.config || {}, u2 = [];
          return this.each(function(e2) {
            if (!("INPUT" === d(this).prop("tagName").toUpperCase() && "file" === d(this).attr("type").toLowerCase() && f.FileReader) || !this.files || 0 === this.files.length) return true;
            for (var t = 0; t < this.files.length; t++) u2.push({ file: this.files[t], inputElem: this, instanceConfig: d.extend({}, r2) });
          }), e(), this;
          function e() {
            if (0 !== u2.length) {
              var e2, t, r3, i, n2 = u2[0];
              if (J(o2.before)) {
                var s2 = o2.before(n2.file, n2.inputElem);
                if ("object" == typeof s2) {
                  if ("abort" === s2.action) return e2 = "AbortError", t = n2.file, r3 = n2.inputElem, i = s2.reason, void (J(o2.error) && o2.error({ name: e2 }, t, r3, i));
                  if ("skip" === s2.action) return void h2();
                  "object" == typeof s2.config && (n2.instanceConfig = d.extend(n2.instanceConfig, s2.config));
                } else if ("skip" === s2) return void h2();
              }
              var a2 = n2.instanceConfig.complete;
              n2.instanceConfig.complete = function(e3) {
                J(a2) && a2(e3, n2.file, n2.inputElem), h2();
              }, b.parse(n2.file, n2.instanceConfig);
            } else J(o2.complete) && o2.complete();
          }
          function h2() {
            u2.splice(0, 1), e();
          }
        };
      }
      function h(e) {
        this._handle = null, this._finished = false, this._completed = false, this._halted = false, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = true, this._completeResults = { data: [], errors: [], meta: {} }, function(e2) {
          var t = w(e2);
          t.chunkSize = parseInt(t.chunkSize), e2.step || e2.chunk || (t.chunkSize = null);
          this._handle = new r(t), (this._handle.streamer = this)._config = t;
        }.call(this, e), this.parseChunk = function(e2, t) {
          if (this.isFirstChunk && J(this._config.beforeFirstChunk)) {
            var r2 = this._config.beforeFirstChunk(e2);
            void 0 !== r2 && (e2 = r2);
          }
          this.isFirstChunk = false, this._halted = false;
          var i = this._partialLine + e2;
          this._partialLine = "";
          var n2 = this._handle.parse(i, this._baseIndex, !this._finished);
          if (!this._handle.paused() && !this._handle.aborted()) {
            var s2 = n2.meta.cursor;
            this._finished || (this._partialLine = i.substring(s2 - this._baseIndex), this._baseIndex = s2), n2 && n2.data && (this._rowCount += n2.data.length);
            var a2 = this._finished || this._config.preview && this._rowCount >= this._config.preview;
            if (o) f.postMessage({ results: n2, workerId: b.WORKER_ID, finished: a2 });
            else if (J(this._config.chunk) && !t) {
              if (this._config.chunk(n2, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = true);
              n2 = void 0, this._completeResults = void 0;
            }
            return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(n2.data), this._completeResults.errors = this._completeResults.errors.concat(n2.errors), this._completeResults.meta = n2.meta), this._completed || !a2 || !J(this._config.complete) || n2 && n2.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = true), a2 || n2 && n2.meta.paused || this._nextChunk(), n2;
          }
          this._halted = true;
        }, this._sendError = function(e2) {
          J(this._config.error) ? this._config.error(e2) : o && this._config.error && f.postMessage({ workerId: b.WORKER_ID, error: e2, finished: false });
        };
      }
      function l(e) {
        var i;
        (e = e || {}).chunkSize || (e.chunkSize = b.RemoteChunkSize), h.call(this, e), this._nextChunk = n ? function() {
          this._readChunk(), this._chunkLoaded();
        } : function() {
          this._readChunk();
        }, this.stream = function(e2) {
          this._input = e2, this._nextChunk();
        }, this._readChunk = function() {
          if (this._finished) this._chunkLoaded();
          else {
            if (i = new XMLHttpRequest(), this._config.withCredentials && (i.withCredentials = this._config.withCredentials), n || (i.onload = v(this._chunkLoaded, this), i.onerror = v(this._chunkError, this)), i.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !n), this._config.downloadRequestHeaders) {
              var e2 = this._config.downloadRequestHeaders;
              for (var t in e2) i.setRequestHeader(t, e2[t]);
            }
            if (this._config.chunkSize) {
              var r2 = this._start + this._config.chunkSize - 1;
              i.setRequestHeader("Range", "bytes=" + this._start + "-" + r2);
            }
            try {
              i.send(this._config.downloadRequestBody);
            } catch (e3) {
              this._chunkError(e3.message);
            }
            n && 0 === i.status && this._chunkError();
          }
        }, this._chunkLoaded = function() {
          4 === i.readyState && (i.status < 200 || 400 <= i.status ? this._chunkError() : (this._start += this._config.chunkSize ? this._config.chunkSize : i.responseText.length, this._finished = !this._config.chunkSize || this._start >= function(e2) {
            var t = e2.getResponseHeader("Content-Range");
            if (null === t) return -1;
            return parseInt(t.substring(t.lastIndexOf("/") + 1));
          }(i), this.parseChunk(i.responseText)));
        }, this._chunkError = function(e2) {
          var t = i.statusText || e2;
          this._sendError(new Error(t));
        };
      }
      function c(e) {
        var i, n2;
        (e = e || {}).chunkSize || (e.chunkSize = b.LocalChunkSize), h.call(this, e);
        var s2 = "undefined" != typeof FileReader;
        this.stream = function(e2) {
          this._input = e2, n2 = e2.slice || e2.webkitSlice || e2.mozSlice, s2 ? ((i = new FileReader()).onload = v(this._chunkLoaded, this), i.onerror = v(this._chunkError, this)) : i = new FileReaderSync(), this._nextChunk();
        }, this._nextChunk = function() {
          this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
        }, this._readChunk = function() {
          var e2 = this._input;
          if (this._config.chunkSize) {
            var t = Math.min(this._start + this._config.chunkSize, this._input.size);
            e2 = n2.call(e2, this._start, t);
          }
          var r2 = i.readAsText(e2, this._config.encoding);
          s2 || this._chunkLoaded({ target: { result: r2 } });
        }, this._chunkLoaded = function(e2) {
          this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(e2.target.result);
        }, this._chunkError = function() {
          this._sendError(i.error);
        };
      }
      function p(e) {
        var r2;
        h.call(this, e = e || {}), this.stream = function(e2) {
          return r2 = e2, this._nextChunk();
        }, this._nextChunk = function() {
          if (!this._finished) {
            var e2, t = this._config.chunkSize;
            return t ? (e2 = r2.substring(0, t), r2 = r2.substring(t)) : (e2 = r2, r2 = ""), this._finished = !r2, this.parseChunk(e2);
          }
        };
      }
      function g(e) {
        h.call(this, e = e || {});
        var t = [], r2 = true, i = false;
        this.pause = function() {
          h.prototype.pause.apply(this, arguments), this._input.pause();
        }, this.resume = function() {
          h.prototype.resume.apply(this, arguments), this._input.resume();
        }, this.stream = function(e2) {
          this._input = e2, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
        }, this._checkIsFinished = function() {
          i && 1 === t.length && (this._finished = true);
        }, this._nextChunk = function() {
          this._checkIsFinished(), t.length ? this.parseChunk(t.shift()) : r2 = true;
        }, this._streamData = v(function(e2) {
          try {
            t.push("string" == typeof e2 ? e2 : e2.toString(this._config.encoding)), r2 && (r2 = false, this._checkIsFinished(), this.parseChunk(t.shift()));
          } catch (e3) {
            this._streamError(e3);
          }
        }, this), this._streamError = v(function(e2) {
          this._streamCleanUp(), this._sendError(e2);
        }, this), this._streamEnd = v(function() {
          this._streamCleanUp(), i = true, this._streamData("");
        }, this), this._streamCleanUp = v(function() {
          this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
        }, this);
      }
      function r(m2) {
        var a2, o2, u2, i = Math.pow(2, 53), n2 = -i, s2 = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, h2 = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, t = this, r2 = 0, f2 = 0, d2 = false, e = false, l2 = [], c2 = { data: [], errors: [], meta: {} };
        if (J(m2.step)) {
          var p2 = m2.step;
          m2.step = function(e2) {
            if (c2 = e2, _2()) g2();
            else {
              if (g2(), 0 === c2.data.length) return;
              r2 += e2.data.length, m2.preview && r2 > m2.preview ? o2.abort() : (c2.data = c2.data[0], p2(c2, t));
            }
          };
        }
        function y2(e2) {
          return "greedy" === m2.skipEmptyLines ? "" === e2.join("").trim() : 1 === e2.length && 0 === e2[0].length;
        }
        function g2() {
          return c2 && u2 && (k("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + b.DefaultDelimiter + "'"), u2 = false), m2.skipEmptyLines && (c2.data = c2.data.filter(function(e2) {
            return !y2(e2);
          })), _2() && function() {
            if (!c2) return;
            function e2(e3, t3) {
              J(m2.transformHeader) && (e3 = m2.transformHeader(e3, t3)), l2.push(e3);
            }
            if (Array.isArray(c2.data[0])) {
              for (var t2 = 0; _2() && t2 < c2.data.length; t2++) c2.data[t2].forEach(e2);
              c2.data.splice(0, 1);
            } else c2.data.forEach(e2);
          }(), function() {
            if (!c2 || !m2.header && !m2.dynamicTyping && !m2.transform) return c2;
            function e2(e3, t3) {
              var r3, i2 = m2.header ? {} : [];
              for (r3 = 0; r3 < e3.length; r3++) {
                var n3 = r3, s3 = e3[r3];
                m2.header && (n3 = r3 >= l2.length ? "__parsed_extra" : l2[r3]), m2.transform && (s3 = m2.transform(s3, n3)), s3 = v2(n3, s3), "__parsed_extra" === n3 ? (i2[n3] = i2[n3] || [], i2[n3].push(s3)) : i2[n3] = s3;
              }
              return m2.header && (r3 > l2.length ? k("FieldMismatch", "TooManyFields", "Too many fields: expected " + l2.length + " fields but parsed " + r3, f2 + t3) : r3 < l2.length && k("FieldMismatch", "TooFewFields", "Too few fields: expected " + l2.length + " fields but parsed " + r3, f2 + t3)), i2;
            }
            var t2 = 1;
            !c2.data.length || Array.isArray(c2.data[0]) ? (c2.data = c2.data.map(e2), t2 = c2.data.length) : c2.data = e2(c2.data, 0);
            m2.header && c2.meta && (c2.meta.fields = l2);
            return f2 += t2, c2;
          }();
        }
        function _2() {
          return m2.header && 0 === l2.length;
        }
        function v2(e2, t2) {
          return r3 = e2, m2.dynamicTypingFunction && void 0 === m2.dynamicTyping[r3] && (m2.dynamicTyping[r3] = m2.dynamicTypingFunction(r3)), true === (m2.dynamicTyping[r3] || m2.dynamicTyping) ? "true" === t2 || "TRUE" === t2 || "false" !== t2 && "FALSE" !== t2 && (function(e3) {
            if (s2.test(e3)) {
              var t3 = parseFloat(e3);
              if (n2 < t3 && t3 < i) return true;
            }
            return false;
          }(t2) ? parseFloat(t2) : h2.test(t2) ? new Date(t2) : "" === t2 ? null : t2) : t2;
          var r3;
        }
        function k(e2, t2, r3, i2) {
          var n3 = { type: e2, code: t2, message: r3 };
          void 0 !== i2 && (n3.row = i2), c2.errors.push(n3);
        }
        this.parse = function(e2, t2, r3) {
          var i2 = m2.quoteChar || '"';
          if (m2.newline || (m2.newline = function(e3, t3) {
            e3 = e3.substring(0, 1048576);
            var r4 = new RegExp(Q(t3) + "([^]*?)" + Q(t3), "gm"), i3 = (e3 = e3.replace(r4, "")).split("\r"), n4 = e3.split("\n"), s4 = 1 < n4.length && n4[0].length < i3[0].length;
            if (1 === i3.length || s4) return "\n";
            for (var a3 = 0, o3 = 0; o3 < i3.length; o3++) "\n" === i3[o3][0] && a3++;
            return a3 >= i3.length / 2 ? "\r\n" : "\r";
          }(e2, i2)), u2 = false, m2.delimiter) J(m2.delimiter) && (m2.delimiter = m2.delimiter(e2), c2.meta.delimiter = m2.delimiter);
          else {
            var n3 = function(e3, t3, r4, i3, n4) {
              var s4, a3, o3, u3;
              n4 = n4 || [",", "	", "|", ";", b.RECORD_SEP, b.UNIT_SEP];
              for (var h3 = 0; h3 < n4.length; h3++) {
                var f3 = n4[h3], d3 = 0, l3 = 0, c3 = 0;
                o3 = void 0;
                for (var p3 = new E({ comments: i3, delimiter: f3, newline: t3, preview: 10 }).parse(e3), g3 = 0; g3 < p3.data.length; g3++) if (r4 && y2(p3.data[g3])) c3++;
                else {
                  var _3 = p3.data[g3].length;
                  l3 += _3, void 0 !== o3 ? 0 < _3 && (d3 += Math.abs(_3 - o3), o3 = _3) : o3 = _3;
                }
                0 < p3.data.length && (l3 /= p3.data.length - c3), (void 0 === a3 || d3 <= a3) && (void 0 === u3 || u3 < l3) && 1.99 < l3 && (a3 = d3, s4 = f3, u3 = l3);
              }
              return { successful: !!(m2.delimiter = s4), bestDelimiter: s4 };
            }(e2, m2.newline, m2.skipEmptyLines, m2.comments, m2.delimitersToGuess);
            n3.successful ? m2.delimiter = n3.bestDelimiter : (u2 = true, m2.delimiter = b.DefaultDelimiter), c2.meta.delimiter = m2.delimiter;
          }
          var s3 = w(m2);
          return m2.preview && m2.header && s3.preview++, a2 = e2, o2 = new E(s3), c2 = o2.parse(a2, t2, r3), g2(), d2 ? { meta: { paused: true } } : c2 || { meta: { paused: false } };
        }, this.paused = function() {
          return d2;
        }, this.pause = function() {
          d2 = true, o2.abort(), a2 = J(m2.chunk) ? "" : a2.substring(o2.getCharIndex());
        }, this.resume = function() {
          t.streamer._halted ? (d2 = false, t.streamer.parseChunk(a2, true)) : setTimeout(t.resume, 3);
        }, this.aborted = function() {
          return e;
        }, this.abort = function() {
          e = true, o2.abort(), c2.meta.aborted = true, J(m2.complete) && m2.complete(c2), a2 = "";
        };
      }
      function Q(e) {
        return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function E(j) {
        var z, M = (j = j || {}).delimiter, P = j.newline, U = j.comments, q = j.step, N = j.preview, B = j.fastMode, K = z = void 0 === j.quoteChar || null === j.quoteChar ? '"' : j.quoteChar;
        if (void 0 !== j.escapeChar && (K = j.escapeChar), ("string" != typeof M || -1 < b.BAD_DELIMITERS.indexOf(M)) && (M = ","), U === M) throw new Error("Comment character same as delimiter");
        true === U ? U = "#" : ("string" != typeof U || -1 < b.BAD_DELIMITERS.indexOf(U)) && (U = false), "\n" !== P && "\r" !== P && "\r\n" !== P && (P = "\n");
        var W = 0, H = false;
        this.parse = function(i, t, r2) {
          if ("string" != typeof i) throw new Error("Input must be a string");
          var n2 = i.length, e = M.length, s2 = P.length, a2 = U.length, o2 = J(q), u2 = [], h2 = [], f2 = [], d2 = W = 0;
          if (!i) return L();
          if (j.header && !t) {
            var l2 = i.split(P)[0].split(M), c2 = [], p2 = {}, g2 = false;
            for (var _2 in l2) {
              var m2 = l2[_2];
              J(j.transformHeader) && (m2 = j.transformHeader(m2, _2));
              var y2 = m2, v2 = p2[m2] || 0;
              for (0 < v2 && (g2 = true, y2 = m2 + "_" + v2), p2[m2] = v2 + 1; c2.includes(y2); ) y2 = y2 + "_" + v2;
              c2.push(y2);
            }
            if (g2) {
              var k = i.split(P);
              k[0] = c2.join(M), i = k.join(P);
            }
          }
          if (B || false !== B && -1 === i.indexOf(z)) {
            for (var b2 = i.split(P), E2 = 0; E2 < b2.length; E2++) {
              if (f2 = b2[E2], W += f2.length, E2 !== b2.length - 1) W += P.length;
              else if (r2) return L();
              if (!U || f2.substring(0, a2) !== U) {
                if (o2) {
                  if (u2 = [], I(f2.split(M)), F(), H) return L();
                } else I(f2.split(M));
                if (N && N <= E2) return u2 = u2.slice(0, N), L(true);
              }
            }
            return L();
          }
          for (var w2 = i.indexOf(M, W), R = i.indexOf(P, W), C = new RegExp(Q(K) + Q(z), "g"), S = i.indexOf(z, W); ; ) if (i[W] !== z) if (U && 0 === f2.length && i.substring(W, W + a2) === U) {
            if (-1 === R) return L();
            W = R + s2, R = i.indexOf(P, W), w2 = i.indexOf(M, W);
          } else if (-1 !== w2 && (w2 < R || -1 === R)) f2.push(i.substring(W, w2)), W = w2 + e, w2 = i.indexOf(M, W);
          else {
            if (-1 === R) break;
            if (f2.push(i.substring(W, R)), D(R + s2), o2 && (F(), H)) return L();
            if (N && u2.length >= N) return L(true);
          }
          else for (S = W, W++; ; ) {
            if (-1 === (S = i.indexOf(z, S + 1))) return r2 || h2.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: u2.length, index: W }), T();
            if (S === n2 - 1) return T(i.substring(W, S).replace(C, z));
            if (z !== K || i[S + 1] !== K) {
              if (z === K || 0 === S || i[S - 1] !== K) {
                -1 !== w2 && w2 < S + 1 && (w2 = i.indexOf(M, S + 1)), -1 !== R && R < S + 1 && (R = i.indexOf(P, S + 1));
                var O = A(-1 === R ? w2 : Math.min(w2, R));
                if (i.substr(S + 1 + O, e) === M) {
                  f2.push(i.substring(W, S).replace(C, z)), i[W = S + 1 + O + e] !== z && (S = i.indexOf(z, W)), w2 = i.indexOf(M, W), R = i.indexOf(P, W);
                  break;
                }
                var x = A(R);
                if (i.substring(S + 1 + x, S + 1 + x + s2) === P) {
                  if (f2.push(i.substring(W, S).replace(C, z)), D(S + 1 + x + s2), w2 = i.indexOf(M, W), S = i.indexOf(z, W), o2 && (F(), H)) return L();
                  if (N && u2.length >= N) return L(true);
                  break;
                }
                h2.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: u2.length, index: W }), S++;
              }
            } else S++;
          }
          return T();
          function I(e2) {
            u2.push(e2), d2 = W;
          }
          function A(e2) {
            var t2 = 0;
            if (-1 !== e2) {
              var r3 = i.substring(S + 1, e2);
              r3 && "" === r3.trim() && (t2 = r3.length);
            }
            return t2;
          }
          function T(e2) {
            return r2 || (void 0 === e2 && (e2 = i.substring(W)), f2.push(e2), W = n2, I(f2), o2 && F()), L();
          }
          function D(e2) {
            W = e2, I(f2), f2 = [], R = i.indexOf(P, W);
          }
          function L(e2) {
            return { data: u2, errors: h2, meta: { delimiter: M, linebreak: P, aborted: H, truncated: !!e2, cursor: d2 + (t || 0) } };
          }
          function F() {
            q(L()), u2 = [], h2 = [];
          }
        }, this.abort = function() {
          H = true;
        }, this.getCharIndex = function() {
          return W;
        };
      }
      function _(e) {
        var t = e.data, r2 = a[t.workerId], i = false;
        if (t.error) r2.userError(t.error, t.file);
        else if (t.results && t.results.data) {
          var n2 = { abort: function() {
            i = true, m(t.workerId, { data: [], errors: [], meta: { aborted: true } });
          }, pause: y, resume: y };
          if (J(r2.userStep)) {
            for (var s2 = 0; s2 < t.results.data.length && (r2.userStep({ data: t.results.data[s2], errors: t.results.errors, meta: t.results.meta }, n2), !i); s2++) ;
            delete t.results;
          } else J(r2.userChunk) && (r2.userChunk(t.results, n2, t.file), delete t.results);
        }
        t.finished && !i && m(t.workerId, t.results);
      }
      function m(e, t) {
        var r2 = a[e];
        J(r2.userComplete) && r2.userComplete(t), r2.terminate(), delete a[e];
      }
      function y() {
        throw new Error("Not implemented.");
      }
      function w(e) {
        if ("object" != typeof e || null === e) return e;
        var t = Array.isArray(e) ? [] : {};
        for (var r2 in e) t[r2] = w(e[r2]);
        return t;
      }
      function v(e, t) {
        return function() {
          e.apply(t, arguments);
        };
      }
      function J(e) {
        return "function" == typeof e;
      }
      return o && (f.onmessage = function(e) {
        var t = e.data;
        void 0 === b.WORKER_ID && t && (b.WORKER_ID = t.workerId);
        if ("string" == typeof t.input) f.postMessage({ workerId: b.WORKER_ID, results: b.parse(t.input, t.config), finished: true });
        else if (f.File && t.input instanceof File || t.input instanceof Object) {
          var r2 = b.parse(t.input, t.config);
          r2 && f.postMessage({ workerId: b.WORKER_ID, results: r2, finished: true });
        }
      }), (l.prototype = Object.create(h.prototype)).constructor = l, (c.prototype = Object.create(h.prototype)).constructor = c, (p.prototype = Object.create(p.prototype)).constructor = p, (g.prototype = Object.create(h.prototype)).constructor = g, b;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  default: () => SyrinscapePlugin
});
module.exports = __toCommonJS(main_exports);

// src/SyrinscapeSettingsTab.ts
var import_obsidian3 = require("obsidian");

// src/SyrinscapePlayerView.ts
var import_obsidian2 = require("obsidian");

// src/SyrinscapeDebug.ts
var syrinscapeDebug = false;
function setDebug(enable) {
  syrinscapeDebug = enable;
}
function debug(...args) {
  if (syrinscapeDebug) {
    console.debug("Syrinscape - ", ...args);
  }
}

// src/SyrinscapeSound.ts
var import_obsidian = require("obsidian");
var SYRINSCAPE_CLASS = "syrinscape-markdown";
var unsubscribeCallbacks = [];
var SyrinscapeSound = class {
  constructor(id, type, title) {
    this.id = id;
    this.type = type;
    this.title = title;
    if (["mood", "sfx", "music", "oneshot", "element"].indexOf(type) === -1) {
      new import_obsidian.Notice(`Please use one of 'mood', 'sfx', 'music' or 'oneshot' for sound type.`);
      throw new Error(`Invalid type ${type} for SyrinscapeSound.`);
    }
    if (type === "element") {
      this.type = "oneshot";
    }
  }
  /**
   * Render the span for the sound element and the controls.
   * @param element - The element to render the span in.
   * @returns The span element.
   */
  renderSpan(element) {
    const syrinscapeDiv = element.createEl("span", { cls: SYRINSCAPE_CLASS });
    if (this.type === "oneshot") {
      this.renderOneshotPlay(syrinscapeDiv);
    } else {
      this.renderSlider(syrinscapeDiv);
    }
    return syrinscapeDiv;
  }
  /**
   * Render the controls for a mood or sfx sound.
   * @param syrinscapeDiv - The div to render the checkbox in.
   */
  renderSlider(syrinscapeDiv) {
    const label = syrinscapeDiv.createEl("label", { cls: "switch", title: this.title ? `Play "${this.title}"` : "Play" });
    const input = label.createEl("input", { type: "checkbox", cls: `${this.type} syrinscape-${this.id}` });
    const span = label.createEl("span", { cls: `slider round ${this.type}` });
    input.addEventListener("change", (e) => {
      if (input.checked) {
        if (this.type === "mood") {
          document.querySelectorAll(".mood").forEach((element) => {
            const inputElement = element;
            if (inputElement.classList.contains("syrinscape-" + this.id)) {
              inputElement.checked = true;
            } else {
              inputElement.checked = false;
            }
          });
        } else {
          document.querySelectorAll(`.${this.type}.syrinscape-${this.id}`).forEach((element) => {
            const inputElement = element;
            inputElement.checked = true;
          });
        }
        this.callSyrinscapeApi("play");
      } else {
        this.callSyrinscapeApi("stop");
        if (this.type === "mood") {
          document.querySelectorAll(`.${this.type}.syrinscape-${this.id}`).forEach((element) => {
            const inputElement = element;
            inputElement.checked = false;
            resetArtwork();
          });
        } else {
          document.querySelectorAll(`.${this.type}.syrinscape-${this.id}`).forEach((element) => {
            const inputElement = element;
            inputElement.checked = false;
          });
        }
      }
    });
    input.addEventListener("click", (e) => {
      e.stopPropagation();
    });
    span.addEventListener("click", (e) => {
      e.preventDefault();
      input.click();
    });
    if (!isSyrinscapeAuthenticated()) {
      debug("Not authenticated, disabling mood/sfx switch.");
      input.addClass("inactive");
      span.addClass("inactive");
    }
  }
  /**
   * Render the play button for a oneshot sound.
   * @param syrinscapeDiv - The div to render the play button in.
   */
  renderOneshotPlay(syrinscapeDiv) {
    const play = syrinscapeDiv.createEl("a", { cls: `${this.type} syrinscape-${this.id}`, text: "\u25B6\uFE0F", title: this.title ? `Play "${this.title}"` : "Play" });
    if (!isSyrinscapeAuthenticated()) {
      debug("Not authenticated, disabling play button.");
      play.addClass("inactive");
    }
    play.addEventListener("click", (e) => {
      e.preventDefault();
      this.callSyrinscapeApi("play");
    });
  }
  /**
  * Uses the local Syrinscape player to control the sound.
  * @param cmd - The command to send to the local player - either play or stop.
  */
  callSyrinscapeApi(cmd) {
    debug(cmd, " ", this.title, "-", this.id, "-", this.type);
    try {
      if (isSyrinscapeAuthenticated()) {
        if (this.type === "mood") {
          if (cmd === "play") {
            syrinscape.player.controlSystem.startMood(this.id);
          } else {
            syrinscape.player.controlSystem.stopMood(this.id);
          }
        } else {
          if (cmd === "play") {
            syrinscape.player.controlSystem.startElements([this.id]);
          } else {
            syrinscape.player.controlSystem.stopElements([this.id]);
          }
        }
      }
    } catch (error) {
      new import_obsidian.Notice(`Failed to ${cmd} ${this.title} in Syrinscape: ${error}`);
    }
  }
};
function registerForSyrinscapeEvents() {
  debug("Registering for syrinscape start/stop event.");
  unsubscribeCallbacks.push(syrinscape.events.stopElement.addListener(stopElement));
  unsubscribeCallbacks.push(syrinscape.events.startElement.addListener(startElement));
  debug("successfully registered for all events.");
}
function unregisterForSyrinscapeEvents() {
  while (unsubscribeCallbacks.length > 0) {
    const unsubscribe = unsubscribeCallbacks.pop();
    if (typeof unsubscribe === "function") {
      unsubscribe();
    }
  }
  while (syrinscape.player.syncSystem.events.onChangeMood._listeners.length > 0) {
    syrinscape.player.syncSystem.events.onChangeMood._listeners.pop();
  }
  while (syrinscape.player.syncSystem.events.onChangeSoundset._listeners.length > 0) {
    syrinscape.player.syncSystem.events.onChangeSoundset._listeners.pop();
  }
  debug("removed all SyrinscapeSound event listeners.");
}
function setAllStopped() {
  debug("setAllStopped");
  document.querySelectorAll(".playing").forEach((element) => {
    element.classList.remove("playing");
  });
  resetArtwork();
  document.querySelectorAll(`.${SYRINSCAPE_CLASS} input`).forEach((element) => {
    const inputElement = element;
    inputElement.checked = false;
  });
}
function stopElement(event) {
  debug("stopElement:", event.detail.elementId);
  const elementsToStop = document.querySelectorAll(`.syrinscape-${event.detail.elementId}`);
  debug("stopElement:", elementsToStop);
  elementsToStop.forEach((element) => {
    element.classList.remove("playing");
    if (element instanceof HTMLInputElement) {
      element.checked = false;
    }
  });
}
function startElement(event) {
  debug("startElement:", event.detail.elementId);
  document.querySelectorAll(`.oneshot.syrinscape-${event.detail.elementId}`).forEach((element) => {
    const inputElement = element;
    inputElement.classList.add("playing");
    setTimeout(() => {
      inputElement.classList.remove("playing");
    }, 3e3);
  });
}

// src/SyrinscapePlayerView.ts
var VIEW_TYPE = "syrinscape-player";
var SyrinscapePlayerView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.unsubscribeCallbacks = [];
    this.plugin = plugin;
    this.icon = "music";
  }
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Syrinscape player";
  }
  /**
   * Build the Syrinscape player view.
   */
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    try {
      this.syrinscapeDiv = container.createDiv({ cls: "syrinscape" });
      this.ctaDiv = this.syrinscapeDiv.createDiv({ cls: "cta alert" });
      this.interfaceDiv = this.syrinscapeDiv.createDiv({ cls: "interface" });
      const visualisationsContainerDiv = this.interfaceDiv.createDiv({ cls: "visualisations-container" });
      this.visualisationsDiv = visualisationsContainerDiv.createDiv({ cls: "visualisations" });
      this.buildVisualizer(this.visualisationsDiv);
      this.buildActivateButton(this.ctaDiv);
      this.buildLaunchButton(this.interfaceDiv);
      this.controlsDiv = this.interfaceDiv.createDiv({ cls: "controls" });
      this.buildStopButton(this.controlsDiv);
      this.buildVolumeControls(this.controlsDiv);
      this.title = this.interfaceDiv.createDiv({ cls: "title" }).createEl("h2", { text: "Syrinscape Player" });
      this.controlsDiv.style.display = "none";
      this.loginDiv = this.interfaceDiv.createDiv({ cls: "syrinscape-alert" });
      this.buildLoginButton(this.loginDiv);
    } catch (error) {
      console.error("Syrinscape - Error building view:", error);
      new import_obsidian2.Notice("Failed to build Syrinscape player view");
      const container2 = this.containerEl.children[1];
      container2.empty();
      this.buildErrorScreen(container2);
    }
    this.app.workspace.onLayoutReady(this.activateSyrinscape.bind(this));
  }
  /**
   * Build an error screen with a reload button that reloads the view.
   * @param container the container to append the error screen to
   */
  buildErrorScreen(container) {
    const errorDiv = container.createDiv({ cls: "alert" });
    errorDiv.createEl("h3", { text: "Failed to build Syrinscape player view" });
    errorDiv.createEl("p", { text: "Please check the console for more information." });
    errorDiv.createEl("button", { text: "Reload", cls: "syrinscape-reload" }).addEventListener("click", () => {
      this.onOpen();
    });
  }
  /**
   * Build a h3 element saying "Authorization required"
   * and explanatory text below it using a flex box.
   * @param parentDiv the div to append the login button to.
   * @returns the login button element
   */
  buildLoginButton(parentDiv) {
    const alertDiv = parentDiv.createDiv({ cls: "alert" });
    alertDiv.createEl("h3", { text: "Authorization required" });
    alertDiv.createEl("p", { text: "Please enter your authentication token in preferences." });
    alertDiv.createEl("button", { text: "Reload", cls: "syrinscape-reload" }).addEventListener("click", () => {
      this.onOpen();
    });
  }
  /**
   * Build the button to activate the syrinscape player - this is where the websocket is established.
   * Assumes that the syrinscape scripts have been loaded and the global syrinscape object is available.
   * @param ctaDiv the div to append the button to
   * @param interfaceDiv the div to show when the player is activated
   * @returns the activate button element
   */
  buildActivateButton(ctaDiv) {
    const activateButton = ctaDiv.createEl("button", { text: "Activate" });
    activateButton.addEventListener("click", this.activateSyrinscape.bind(this));
    activateButton.setAttribute("aria-label", "Activate Syrinscape player");
    return activateButton;
  }
  /**
   * Create the launch button that opens the syrinscape player in an external browser.
   * @param controlsDiv the div to append the button to
   * @returns the launch button element
   */
  buildLaunchButton(controlsDiv) {
    const launch = controlsDiv.createEl("input", { cls: "launch", type: "image" });
    launch.setAttribute("src", "https://app.syrinscape.com/static/basic-player/logo.png");
    launch.setAttribute("width", "100%");
    launch.setAttribute("aria-label", "Launch Syrinscape player in an external browser");
    launch.addEventListener("click", () => {
      syrinscape.integration.launchAsGameMaster();
    });
    return launch;
  }
  /**
   * Create the button that stops all sounds.
   * @param controlsDiv the div to append the button to
   * @returns the stop button element
   */
  buildStopButton(controlsDiv) {
    const stopAll = controlsDiv.createEl("button", { cls: "stopAll", text: "\u23F9\uFE0F" });
    stopAll.addEventListener("click", () => {
      syrinscape.player.controlSystem.stopAll();
      setAllStopped();
    });
    stopAll.setAttribute("aria-label", "Stop all sounds");
    return stopAll;
  }
  /**
   * Build the volume controls for the player - a slider and a mute button.
   * @param parentDiv the div to append the volume controls to
   * @returns an object containing the volume slider and mute button elements
   */
  buildVolumeControls(parentDiv) {
    const volumeStack = parentDiv.createDiv({ cls: "volume-stack" });
    this.localVolume = this.createVolumeSlider(volumeStack, "local-volume", (value) => {
      syrinscape.player.audioSystem.setLocalVolume(value);
      syrinscape.config.lastLocalVolume = value;
    }, "Local");
    this.createVolumeSlider(volumeStack, "oneshot-volume", (value) => {
      syrinscape.player.elementSystem.oneshotSystem.setVolume(value);
    }, "One-shot");
    this.mute = parentDiv.createEl("button", { cls: "mute", text: "\u{1F508}" });
    this.mute.addEventListener("click", () => {
      syrinscape.player.audioSystem.toggleMute();
    });
    this.mute.setAttribute("aria-label", "Mute");
  }
  createVolumeSlider(parentDiv, sliderClass, setVolumeFunction, volumeType) {
    const volumeSlider = parentDiv.createEl("input", { cls: sliderClass, type: "range" });
    volumeSlider.min = "0";
    volumeSlider.max = "1.5";
    volumeSlider.step = "0.01";
    volumeSlider.value = "1";
    const volumeTooltip = parentDiv.createDiv({ cls: "volume-tooltip" });
    volumeTooltip.style.position = "absolute";
    volumeTooltip.style.display = "none";
    const updateTooltip = () => {
      const volumePercentage = Math.round(Number(volumeSlider.value) * 100);
      volumeTooltip.textContent = `${volumeType} Volume: ${volumePercentage}%`;
      const tooltipLeft = volumeSlider.offsetLeft + 30;
      volumeTooltip.style.left = `${tooltipLeft}px`;
      volumeTooltip.style.top = `${volumeSlider.offsetTop - 40}px`;
      volumeTooltip.style.display = "block";
    };
    volumeSlider.addEventListener("input", () => {
      setVolumeFunction(volumeSlider.value);
      updateTooltip();
    });
    volumeSlider.addEventListener("change", () => {
      setVolumeFunction(volumeSlider.value);
      updateTooltip();
    });
    volumeSlider.addEventListener("mouseenter", () => {
      updateTooltip();
    });
    volumeSlider.addEventListener("mouseleave", () => volumeTooltip.style.display = "none");
    return volumeSlider;
  }
  /**
   * Build the visualiser for the player.
   * @param visualisationsDiv the div to append the visualisations to
   * @returns an object containing the frequency and waveform visualiser elements
   */
  buildVisualizer(visualisationsDiv) {
    const frequency = visualisationsDiv.createSvg("svg", { cls: "d3-frequency" });
    const waveform = visualisationsDiv.createSvg("svg", { cls: "d3-waveform" });
    return { "frequency": frequency, "waveform": waveform };
  }
  /**
   * Activate the Syrinscape player - establishing a websocket to syrinscape and
   * setting up event listeners for the player.
   * Must be called only once per view and only after the syrinscape object is available
   * and after onOpen has been called.
   */
  async activateSyrinscape() {
    if (!isSyrinscapeDefined()) {
      console.error("Syrinscape - Syrinscape player not loaded.");
      new import_obsidian2.Notice("Failed to load Syrinscape player. Please check the console for more information.");
      return;
    }
    await syrinscape.config.init();
    this.unsubscribeCallbacks.push(syrinscape.events.playerActive.addListener(this.playerActive.bind(this)));
    const authToken = this.plugin.settings.authToken;
    const ctaDiv = this.ctaDiv;
    const interfaceDiv = this.interfaceDiv;
    this.subscribeToConfigUpdates();
    debug("Logging in to Syrinscape player.");
    syrinscape.player.init({
      async configure() {
        loginToSyrinscape(authToken);
      },
      onActive() {
        if (isSyrinscapeAuthenticated()) {
          console.log("Syrinscape - successfully logged in to app.syrinscape.com.");
          document.querySelectorAll(`.${SYRINSCAPE_CLASS} a.inactive`).forEach((element) => {
            element.classList.remove("inactive");
          });
          document.querySelectorAll(`.${SYRINSCAPE_CLASS} input.inactive`).forEach((element) => {
            element.classList.remove("inactive");
          });
          document.querySelectorAll(`.${SYRINSCAPE_CLASS} span.inactive`).forEach((element) => {
            element.classList.remove("inactive");
          });
        } else {
          console.log("Syrinscape - failed to log in. Please check your authentication token.");
          document.querySelectorAll(`.${SYRINSCAPE_CLASS} a`).forEach((element) => {
            element.classList.add("inactive");
          });
          new import_obsidian2.Notice("Failed to log in to Syrinscape player. Please check your authentication token in preferences.");
        }
        if (ctaDiv) ctaDiv.style.display = "none";
        if (interfaceDiv) interfaceDiv.style.display = "block";
      },
      onInactive() {
        debug("logged out/deactivated.");
        document.querySelectorAll(`.${SYRINSCAPE_CLASS} a`).forEach((element) => {
          element.classList.add("inactive");
        });
        if (ctaDiv) ctaDiv.style.display = "block";
        if (interfaceDiv) interfaceDiv.style.display = "none";
      }
    });
  }
  playerActive() {
    debug("Player active.");
    registerForSyrinscapeEvents();
    if (this.localVolume) this.localVolume.value = syrinscape.config.lastLocalVolume || "1";
    this.subscribeToArtworkChanges();
    this.subscribeToVolumeEvents();
    this.subscribeToVisualizerUpdates();
  }
  /**
   * Subscribe to undocumented APIs to allow for updating the player view background image and title.
   */
  subscribeToArtworkChanges() {
    const events = syrinscape.player.syncSystem.events;
    events.onChangeMood.addListener(this.updateTitle.bind(this));
    events.onChangeSoundset.addListener(this.updateArtwork.bind(this));
  }
  updateTitle(event) {
    if (this.title) this.title.textContent = event.title;
  }
  updateArtwork(event) {
    if (this.syrinscapeDiv) this.syrinscapeDiv.style.backgroundImage = `url(${event.artwork})`;
  }
  /**
   * Subscribe to the visualiser updates to update the frequency and waveform visualisations.
   */
  subscribeToVisualizerUpdates() {
    syrinscape.visualisation.add("global", () => {
      const data = syrinscape.player.audioEffectSystem.analyser.getData();
      syrinscape.visualisation.d3VisualiseFrequencyData(data, ".d3-frequency");
      syrinscape.visualisation.d3VisualiseWaveformData(data, ".d3-waveform");
      return syrinscape.player.audioEffectSystem.analyser.isActive;
    });
  }
  /**
   * Subscribe to config updates to show/hide the login div and show/hide the player interface.
   */
  subscribeToConfigUpdates() {
    this.unsubscribeCallbacks.push(syrinscape.events.updateConfig.addListener(this.configUpdated.bind(this)));
  }
  configUpdated(event) {
    var _a;
    if (!this.loginDiv || !this.title || !this.controlsDiv || !this.visualisationsDiv) return;
    debug("updateConfig: ", event);
    if (event.detail.authenticated || ((_a = syrinscape.config) == null ? void 0 : _a.authenticated)) {
      this.loginDiv.style.display = "none";
      this.title.style.display = "block";
      this.controlsDiv.style.display = "flex";
      this.visualisationsDiv.style.display = "block";
    } else {
      this.loginDiv.style.display = "flex";
      this.title.style.display = "none";
      this.controlsDiv.style.display = "none";
      this.visualisationsDiv.style.display = "none";
    }
  }
  /**
   * Subscribe to volume events to update the local volume slider and mute button.
   */
  subscribeToVolumeEvents() {
    this.unsubscribeCallbacks.push(syrinscape.events.setLocalVolume.addListener(this.setLocalVolume.bind(this)));
  }
  /**
   * Update the local volume slider and mute button based on slider movement.
   * @param event the event containing the volume value
   * @returns void
   */
  setLocalVolume(event) {
    if (!this.localVolume || !this.mute) return;
    this.localVolume.value = event.detail;
    const volume = Number(event.detail);
    if (volume === 0) {
      this.mute.textContent = "\u{1F507}";
    } else {
      if (volume < 0.5) {
        this.mute.textContent = "\u{1F508}";
      } else if (volume < 1) {
        this.mute.textContent = "\u{1F509}";
      } else {
        this.mute.textContent = "\u{1F50A}";
      }
    }
  }
  /**
   * Called when the view is closed.
   */
  async onClose() {
    debug("Closing view.");
    setAllStopped();
    if (syrinscape.config) {
      syrinscape.player.controlSystem.stopAll();
    }
  }
  onunload() {
    debug("Unloading view");
    unregisterForSyrinscapeEvents();
    syrinscape.visualisation.add("global", () => {
      return false;
    });
    while (this.unsubscribeCallbacks.length > 0) {
      const unsubscribe = this.unsubscribeCallbacks.pop();
      if (unsubscribe && typeof unsubscribe === "function") {
        unsubscribe();
      }
    }
    debug("Unsubscribed from all events.");
  }
};
function loginToSyrinscape(authToken) {
  try {
    if (!syrinscape.config.audioContext)
      syrinscape.config.audioContext = new AudioContext();
    syrinscape.config.token = authToken;
    syrinscape.config.sync();
  } catch (error) {
    console.error("Syrinscape - Error configuring player:", error);
    new import_obsidian2.Notice("Failed to configure Syrinscape player. Please check the console for more information.");
  }
}
function isSyrinscapeDefined() {
  return "syrinscape" in window;
}
function isSyrinscapeLoaded() {
  try {
    return isSyrinscapeDefined() && syrinscape.config && syrinscape.player && syrinscape.player.syncSystem && syrinscape.player.syncSystem.events;
  } catch (error) {
    return false;
  }
}
function isSyrinscapeAuthenticated() {
  try {
    return isSyrinscapeLoaded() && syrinscape.config.authenticated;
  } catch (error) {
    return false;
  }
}
function resetArtwork() {
  document.querySelectorAll(".syrinscape").forEach((element) => {
    const syrinscapeDiv = element;
    syrinscapeDiv.style.backgroundImage = 'url("https://syrinscape.com/static/img/BG-Base.jpg")';
  });
  document.querySelectorAll(".title h2").forEach((element) => {
    const title = element;
    title.textContent = "Syrinscape Player";
  });
}

// src/SyrinscapeSettingsTab.ts
var SyrinscapeSettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const desc = new DocumentFragment();
    desc.appendText("Enter your Syrinscape Auth token here. You can find it in your ");
    desc.append(desc.createEl("a", { "href": "https://syrinscape.com/online/cp/", text: "Syrinscape control panel." }));
    desc.append(desc.createEl("br"));
    desc.appendText("This plugin will only control the Syrinscape Web Player or Online Player.");
    desc.append(desc.createEl("br"));
    desc.appendText("This plugin will not control the Syrinscape Fantasy Player or Sci-Fi Player.");
    new import_obsidian3.Setting(containerEl).setName("Auth token").setDesc(desc).addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.authToken).setValue(this.plugin.settings.authToken).onChange(async (value) => {
      this.plugin.settings.authToken = value;
      if (isSyrinscapeDefined()) {
        syrinscape.config.token = "";
        syrinscape.config.sync();
        syrinscape.config.token = value;
        for (const leaf of this.plugin.app.workspace.getLeavesOfType(VIEW_TYPE)) {
          const view = leaf.view;
          if (view instanceof SyrinscapePlayerView) {
            view.activateSyrinscape();
          }
        }
        await this.plugin.saveData(this.plugin.settings);
      }
    }).inputEl.setAttr("type", "password"));
    new import_obsidian3.Setting(containerEl).setName("Cache age").setDesc(`Enter the maximum age of the cache in days. Default is ${DEFAULT_SETTINGS.maxCacheAge.toString()} days.`).addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.maxCacheAge.toString()).setValue(this.plugin.settings.maxCacheAge.toString()).onChange(async (value) => {
      this.plugin.settings.maxCacheAge = parseInt(value);
      await this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian3.Setting(containerEl).setName("Trigger word").setDesc('Enter the word that the Syrinscape player plugin will look for. Default is "syrinscape"').addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.triggerWord).setValue(this.plugin.settings.triggerWord).onChange(async (value) => {
      this.plugin.settings.triggerWord = value;
      await this.plugin.saveData(this.plugin.settings);
    }));
    const buttonDesc = new DocumentFragment();
    buttonDesc.appendText("This plugin will cache remote control links for at most ");
    buttonDesc.createEl("i").appendText("Cache age");
    buttonDesc.appendText(" days.");
    buttonDesc.append(desc.createEl("br"));
    buttonDesc.appendText("You can manually clear the Remote Links that were downloaded from Syrinscape on ");
    const dateText = buttonDesc.createEl("b");
    dateText.appendText(this.plugin.settings.lastUpdated ? this.plugin.settings.lastUpdated.toDateString() : "never");
    buttonDesc.append(dateText);
    new import_obsidian3.Setting(containerEl).setName("Clear remote links").setDesc(buttonDesc).addButton((button) => button.setButtonText("Clear remote links").onClick(async () => {
      var _a;
      this.plugin.clearCache();
      (_a = this.plugin.editorSuggest) == null ? void 0 : _a.fetchRemoteLinks();
    }));
    new import_obsidian3.Setting(containerEl).setName("Debug logging").setDesc("Enable debug logging to the console.").addToggle((toggle) => toggle.setValue(this.plugin.settings.debug).onChange(async (value) => {
      this.plugin.settings.debug = value;
      await this.plugin.saveData(this.plugin.settings);
    }));
  }
};

// src/SyrinscapeSuggest.ts
var import_obsidian4 = require("obsidian");
var Papa = __toESM(require_papaparse_min());
var SyrinscapeSuggest = class extends import_obsidian4.EditorSuggest {
  constructor(app, plugin) {
    super(app);
    // Map of title to Syrinscape Completion objects
    this.remoteLinks = /* @__PURE__ */ new Map();
    this.app = app;
    this.plugin = plugin;
  }
  /**
   * Split the query into words and return the completions that match every word in the query, regardless of order.
   * @param context the context object containing the query and the editor
   * @returns a list of completions that match every word in the query
   */
  getSuggestions(context) {
    const query = context.query.toLowerCase();
    const queryWords = query.split(" ");
    const completions = Array.from(this.remoteLinks.values());
    if (!query) {
      return completions;
    }
    return completions.filter((completion) => {
      const titleWords = completion.title.toLowerCase().split(" ");
      titleWords.push(completion.id, completion.type);
      return queryWords.every((queryWord) => titleWords.some((titleWord) => titleWord.contains(queryWord)));
    });
  }
  /**
   * Download the CSV file of remote links from the Syrinscape website and parse it into the remoteLinks map.
   * @returns a promise that fetches the remote links from the Syrinscape website and parses them into the remoteLinks map.
   */
  async fetchRemoteLinks() {
    if (this.plugin.settings.csvContent.length > 0) {
      debug(`Syrinscape - Remote links already fetched. Skipping download.`);
      this.parseRemoteLinks(this.plugin.settings.csvContent);
      return;
    }
    debug("Syrinscape - Downloading CSV file of remote links.");
    try {
      const response = await (0, import_obsidian4.requestUrl)({
        url: "https://syrinscape.com/account/remote-control-links-csv/",
        method: "GET",
        contentType: "application",
        headers: {
          "Authorization": `Token ${this.plugin.settings.authToken}`
        }
      });
      const csvContent = response.text;
      this.plugin.settings.csvContent = csvContent;
      this.plugin.settings.lastUpdated = /* @__PURE__ */ new Date();
      await this.plugin.saveSettings();
      new import_obsidian4.Notice("Completed download of Syrinscape remote links");
      this.parseRemoteLinks(csvContent);
    } catch (error) {
      console.error("Syrinscape - Failed to fetch remote links:", error);
      new import_obsidian4.Notice("Failed to fetch Syrinscape remote links.");
    }
  }
  /**
   * Convert the CSV content into a map of remote links.
   * @param csvContent the CSV content to parse into the remoteLinks map
   */
  parseRemoteLinks(csvContent) {
    Papa.parse(csvContent, {
      header: true,
      skipEmptyLines: true,
      complete: (results) => {
        this.remoteLinks.clear();
        for (const row of results.data) {
          const soundTitle = `${row.name} (${row.soundset})`;
          const sound = new SyrinscapeSound(row.id.substring(2), row.type === "element" ? row.sub_type : row.type, soundTitle);
          this.remoteLinks.set(`${sound.type} ${sound.id} ${sound.title.toLowerCase()}`, sound);
        }
        debug(`Syrinscape - Completed parsing of CSV file of ${this.remoteLinks.size} remote links`);
      },
      error: (error) => {
        console.error("Syrinscape - Error parsing CSV:", error);
      }
    });
  }
  /**
   * Display the suggestion in the suggestions container.
   * @param suggestion The suggestion to render
   * @param el the HTML element to render the suggestion in
   */
  renderSuggestion(suggestion, el) {
    return el.createSpan({ cls: "syrinscape-suggestion", text: `${suggestion.type}:${suggestion.id}:${suggestion.title}` });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  selectSuggestion(suggestion, _evt) {
    debug("selectSuggestion:", suggestion);
    const editor = this.context.editor;
    const selectedText = `${suggestion.type}:${suggestion.id}:${suggestion.title}`;
    const from = { ch: editor.getCursor("from").ch - this.context.query.length, line: editor.getCursor("from").line };
    editor.replaceRange(selectedText, from, editor.getCursor("to"));
  }
  findTriggerWordOccurrence(editorLine, triggerWord, cursor) {
    const textBeforeCursor = editorLine.slice(0, cursor);
    const triggerWordIndex = textBeforeCursor.lastIndexOf(triggerWord);
    return triggerWordIndex;
  }
  /** 
   * This method is called on every key press. Returns null as quickly as possible if this class cannot
   * service the request for code completions (e.g. it doesn't match the trigger word).
   * If it does, then it should return an EditorSuggestTriggerInfo object with the range of the trigger word and the query.
   * That EditorSuggestTriggerInfo object will be passed to getSuggestions as an EditorSuggestContext.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onTrigger(cursor, editor, _file) {
    const triggerWord = `\`${this.plugin.settings.triggerWord}:`;
    const startOfTriggerWord = this.findTriggerWordOccurrence(editor.getLine(cursor.line), triggerWord, cursor.ch);
    if (startOfTriggerWord < 0) {
      return null;
    }
    const startPos = { line: cursor.line, ch: startOfTriggerWord };
    const query = editor.getLine(cursor.line).slice(startOfTriggerWord + triggerWord.length, cursor.ch);
    startPos.ch = startOfTriggerWord;
    return {
      start: startPos,
      end: cursor,
      query
    };
  }
};

// src/main.ts
var import_obsidian7 = require("obsidian");

// src/SyrinscapeRenderChild.ts
var import_obsidian5 = require("obsidian");
var SyrinscapeRenderChild = class extends import_obsidian5.MarkdownRenderChild {
  /**
   * Creates an instance of SyrinscapeRenderChild.
   * @param element - The HTML element to render the Syrinscape sound.
   * @param type - The type of the Syrinscape sound.
   * @param soundid - The ID of the Syrinscape sound.
   * @param soundTitle - The title of the Syrinscape sound.
   */
  constructor(element, sound) {
    super(element);
    this.element = element;
    this.sound = sound;
  }
  /**
   * Renders the Syrinscape sound as a play or play&stop button.
   */
  onload() {
    const syrinscapeSpan = this.sound.renderSpan(this.element);
    this.element.replaceWith(syrinscapeSpan);
  }
};

// src/SyrinscapePlayerWidget.ts
var import_view = require("@codemirror/view");
var import_language = require("@codemirror/language");
var import_obsidian6 = require("obsidian");
function selectionAndRangeOverlap(selection, rangeFrom, rangeTo) {
  for (const range of selection.ranges) {
    if (range.from <= rangeTo && range.to >= rangeFrom) {
      return true;
    }
  }
  return false;
}
function inlineRender(view, plugin) {
  const currentFile = this.app.workspace.getActiveFile();
  if (!currentFile) {
    return;
  }
  const widgets = [];
  const selection = view.state.selection;
  const regex = new RegExp(".*?_?inline-code_?.*");
  for (const { from, to } of view.visibleRanges) {
    (0, import_language.syntaxTree)(view.state).iterate({
      from,
      to,
      enter: ({ node }) => {
        const type = node.type;
        if (type.name.includes("formatting")) return;
        if (!regex.test(type.name)) return;
        const start = node.from;
        const end = node.to;
        if (selectionAndRangeOverlap(selection, start, end)) return;
        const original = view.state.doc.sliceString(start, end).trim();
        if (!/^syrinscape(?:\+|-|-mod)?:\s*([\s\S]+)\s*?/.test(original))
          return;
        const sound = plugin.parseSoundString(original);
        if (!sound) return;
        const widget = new SyrinscapePlayerWidget(
          original,
          view,
          plugin,
          sound
        );
        widgets.push(
          import_view.Decoration.replace({
            widget,
            inclusive: false,
            block: false
          }).range(start - 1, end + 1)
        );
      }
    });
  }
  return import_view.Decoration.set(widgets, true);
}
var SyrinscapePlayerWidget = class extends import_view.WidgetType {
  constructor(rawQuery, view, plugin, sound) {
    super();
    this.rawQuery = rawQuery;
    this.view = view;
    this.plugin = plugin;
    this.sound = sound;
  }
  // Widgets only get updated when the raw query changes/the element gets focus and loses it
  // to prevent redraws when the editor updates.
  eq(other) {
    return other.rawQuery === this.rawQuery;
  }
  toDOM() {
    const element = document.createElement("span");
    this.sound.renderSpan(element);
    return element;
  }
  /* Make queries only editable when shift is pressed (or navigated inside with the keyboard
   * or the mouse is placed at the end, but that is always possible regardless of this method).
   * Mostly useful for links, and makes results selectable.
   * If the widgets should always be expandable, make this always return false.
   */
  ignoreEvent(event) {
    if (event.type === "mousedown") {
      const currentPos = this.view.posAtCoords({
        x: event.x,
        y: event.y
      });
      if (event.shiftKey) {
        if (currentPos) {
          const { editor } = this.view.state.field(import_obsidian6.editorEditorField).state.field(import_obsidian6.editorInfoField);
          if (editor) {
            editor.setCursor(editor.offsetToPos(currentPos));
          }
        }
        return false;
      }
    }
    return true;
  }
};
function inlinePlugin(plugin) {
  return import_view.ViewPlugin.fromClass(
    class {
      constructor() {
        this.decorations = import_view.Decoration.none;
      }
      update(update) {
        var _a;
        if (!update.state.field(import_obsidian6.editorLivePreviewField)) {
          this.decorations = import_view.Decoration.none;
          return;
        }
        if (update.docChanged || update.viewportChanged || update.selectionSet) {
          this.decorations = (_a = inlineRender(update.view, plugin)) != null ? _a : import_view.Decoration.none;
        }
      }
    },
    { decorations: (v) => v.decorations }
  );
}

// src/main.ts
var DEFAULT_SETTINGS = {
  authToken: "",
  triggerWord: "syrinscape",
  csvContent: "",
  lastUpdated: null,
  maxCacheAge: 7,
  debug: false
};
var SyrinscapePlugin = class extends import_obsidian7.Plugin {
  /**
   * Load the plugin and register the settings, markdown post processor, and view.
   */
  async onload() {
    await this.loadSettings();
    this.app.workspace.trigger("parse-style-settings");
    await this.loadSyrinscapeScripts();
    this.addSettingTab(new SyrinscapeSettingsTab(this.app, this));
    this.registerMarkdownPostProcessor(this.markdownPostProcessor.bind(this));
    await this.checkForExpiredData();
    this.registerView(
      VIEW_TYPE,
      (leaf) => new SyrinscapePlayerView(leaf, this)
    );
    this.addRibbonIcon("speaker", "Open Syrinscape Player", () => {
      this.activateView();
    });
    this.registerEditorExtension([inlinePlugin(this)]);
    this.app.workspace.onLayoutReady(() => {
      this.editorSuggest = new SyrinscapeSuggest(this.app, this);
      this.registerEditorSuggest(this.editorSuggest);
      this.editorSuggest.fetchRemoteLinks();
      console.log("Syrinscape loaded");
    });
  }
  /**
   * Create or activate the Syrinscape Player view.
   */
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE, active: true });
        workspace.revealLeaf(leaf);
      }
    }
  }
  /**
   * Clear the cache of the Syrinscape data.
   */
  clearCache() {
    this.settings.csvContent = "";
    this.settings.lastUpdated = null;
    this.saveSettings();
  }
  /**
   * if the lastUpdated is more than settings.maxCacheAge days ago, fetch the remote links
   */
  async checkForExpiredData() {
    debug("lastUpdated:", this.settings.lastUpdated);
    if (this.settings.lastUpdated) {
      const now = /* @__PURE__ */ new Date();
      const diff = now.getTime() - this.settings.lastUpdated.getTime();
      const diffDays = Math.floor(diff / (1e3 * 60 * 60 * 24));
      if (diffDays > this.settings.maxCacheAge) {
        debug(`Last updated ${diffDays} day(s) ago, more than ${this.settings.maxCacheAge}. Clearing cache`);
        this.clearCache();
      } else {
        debug(`Last updated ${diffDays} day(s) ago. Cache is still valid`);
      }
    }
  }
  /**
   * Finds all code blocks that match `syrinscape:type:id:title` and creates a SyrinscapeRenderChild to render the buttons.
   * @param element the element to process
   * @param context the editor context
   * @returns 
   */
  async markdownPostProcessor(element, context) {
    const codes = element.querySelectorAll("code");
    if (!codes.length) {
      return;
    }
    codes.forEach((codeBlock) => {
      if (!codeBlock.textContent) {
        return;
      }
      const sound = this.parseSoundString(codeBlock.textContent);
      if (!sound) {
        return;
      }
      context.addChild(new SyrinscapeRenderChild(codeBlock, sound));
    });
  }
  /**
   * Try to parse a sound string in the format `syrinscape:type:id:title` and return a SyrinscapeSound object if successful.
   * @param soundString the string to parse
   * @returns a SyrinscapeSound object if the string is in the correct format, otherwise null
   */
  parseSoundString(soundString) {
    const triggerRegEx = new RegExp(`^${this.settings.triggerWord}:(mood|element|sfx|music|oneshot):([0-9]+)(:(.+))?$`, "ig");
    const matchArray = triggerRegEx.exec(soundString);
    if (!matchArray) {
      return null;
    }
    const type = matchArray[1];
    const id = matchArray[2];
    const title = matchArray[4];
    return new SyrinscapeSound(id, type, title);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    setDebug(this.settings.debug);
    this.settings.lastUpdated = this.settings.lastUpdated ? new Date(this.settings.lastUpdated) : null;
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Load the Syrinscape scripts that construct the player.
   */
  async loadSyrinscapeScripts() {
    this.loadExternalScript("https://syrinscape.com/integration.js").then(() => debug("integration.js script loaded successfully.")).catch((error) => console.error("Error loading script:", error));
    this.loadExternalScript("https://syrinscape.com/player.js").then(() => debug("player.js script loaded successfully.")).catch((error) => console.error("Error loading script:", error));
    this.loadExternalScript("https://syrinscape.com/visualisation.js").then(() => {
      debug("visualization.js script loaded successfully.");
    }).catch((error) => console.error("Error loading script:", error));
  }
  /**
   * Load an external script.
   * @param scriptUrl the URL of the script to load
   * @returns a promise that resolves when the script is loaded
   */
  loadExternalScript(scriptUrl) {
    return new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.src = scriptUrl;
      script.onload = () => resolve();
      script.onerror = () => reject(new Error(`Failed to load script: ${scriptUrl}`));
      document.head.appendChild(script);
    });
  }
};
/*! Bundled license information:

papaparse/papaparse.min.js:
  (* @license
  Papa Parse
  v5.4.1
  https://github.com/mholt/PapaParse
  License: MIT
  *)
*/
